/*

[Item-parser Syntax Information]

1. [Keyword] separates into two groups
   - [Property Keywords] : [Type], [Name], [Class], [Quality], [Flag], [Level], [Prefix], [Suffix]
   - [Stat Keywords] : [Number or Alias]

2. [Keyword] must be surrounded by '[' and ']'

3. [Property Keywords] must be placed first

4. Insert '#' symbol between [Property Keywords] and [Stat Keywords]

5. Use '+', '-', '*', '/', '(', ')', '&&', '||', '>', '>=', '<', '<=', '==', '!=' symbols for comparison

6. Use '//' symbol for comment

*/

include("NTItemAlias.dbl");

var _NTIP_CheckList = new Array();
var stringArray = [];

function NTIPOpenFile(filepath)
{
	var _nipfile;
	var _line;
	var string;
	var count = 0;

	_nipfile = File.open(filepath, 0);

	if(!_nipfile)
		return false;

	while(!_nipfile.eof)
	{
		string = _nipfile.readLine();
		_line = NTIPParseLineInt(string);
		count += 1;

		if (_line) {
			_NTIP_CheckList.push(_line);
			stringArray.push({string: string, count: count, file: filepath.substring(filepath.lastIndexOf("/") + 1, filepath.length)});
		}
	}

	_nipfile.close();

	return true;
}

function NTIPCheckItem(item, list, verbose) {
	if (!list) {
		list = _NTIP_CheckList;
	}

	var i;
	var _identified;
	var _result = 0;

	_identified = item.getFlag(0x10);

	for (i = 0 ; i < list.length ; i++) {
		try {
			if (list[i][0].length > 0) {
				if (eval(list[i][0])) {
					if (list[i][1].length > 0) {
						if (eval(list[i][1])) {
							if (list[i][2] && list[i][2]["MaxQuantity"] && !isNaN(list[i][2]["MaxQuantity"])) {
								if (NTIP_CheckQuantityOwned(list[i][0],list[i][1], false) < list[i][2]["MaxQuantity"]) {
									//print("I need more of these "+NTC_ItemQualityToMGRColor[item.quality] + item.itemdesc.split("\n")[0].substring(3));
									//return 1;
									_result = 1;
									
									break;
								} else {
									//print("I already have enough of these "+NTC_ItemQualityToMGRColor[item.quality] + item.itemdesc.split("\n")[0].substring(3)+" in my stash!");
									//return 0;
									break;
								}
							} else {
								//print("No maximum for this item");
								//return 1;
								_result = 1;

								break;
							}
						} else if (!_identified && _result == 0) {
							_result = -1;
						}
					} else {
						if (list[i][2] && list[i][2]["MaxQuantity"] && !isNaN(list[i][2]["MaxQuantity"])) {
							if (NTIP_CheckQuantityOwned(list[i][0], null, false) < list[i][2]["MaxQuantity"]) {
								//print("I need more of these "+NTC_ItemQualityToMGRColor[item.quality] + item.itemdesc.split("\n")[0].substring(3));
								//return 1;
								_result = 1;

								break;
							} else {
								//print("I already have enough of these "+NTC_ItemQualityToMGRColor[item.quality] + item.itemdesc.split("\n")[0].substring(3)+" in my stash!");
								//return 0;
								break;
							}
						} else {
							//print("No maximum for this item");
							//return 1;
							_result = 1;

							break;
						}
					}
				}
			} else if(list[i][1].length > 0) {
				if (eval(list[i][1])) {
					if (list[i][2] && list[i][2]["MaxQuantity"] && !isNaN(list[i][2]["MaxQuantity"])) {
						if (NTIP_CheckQuantityOwned(null, list[i][1], false) < list[i][2]["MaxQuantity"]) {
							//print("I need more of these "+NTC_ItemQualityToMGRColor[item.quality] + item.itemdesc.split("\n")[0].substring(3));
							//return 1;
							_result = 1;

							break;
						} else {
							//print("I already have enough of these "+NTC_ItemQualityToMGRColor[item.quality] + item.itemdesc.split("\n")[0].substring(3)+" in my stash!");
							//return 0;
							break;
						}
					} else {
						//return 1;
						_result = 1;

						break;
					}
				} else if(!_identified && _result == 0) {
					_result = -1;
				}
			}
		} catch (pickError) {
			showConsole();

			if (arguments.length === 1) {
				print("ÿc1Pickit error! Line # ÿc2" + stringArray[i].count + " ÿc1Entry: ÿc0" + stringArray[i].string + " (" + stringArray[i].file + ")");

				_NTIP_CheckList[i] = ["", "", ""]; // make the bad entry blank
			} else {
				print("ÿc1Pickit error in runeword config!");
			}
		}
	}
	
	if (verbose) {
		if (_result > 0) {
			return {line: stringArray[i].file + " #" + stringArray[i].count, result: _result};
		} else {
			return {line: null, result: _result};
		}
	}

	return _result;
}

// Internal function
function NTIP_CheckQuantityOwned(item_type, item_stats, check_inventory_too)
{
	var _nb = 0;
	var _items = me.getItems();
	if (!_items)
	{
		print("I can't find my items!");
		return 0;
	}
	for(var i = 0 ; i < _items.length ; i++)
	{
		if(_items[i].mode == 0 && _items[i].location == 7)
		{
			var item = _items[i];
			if((item_type != null && item_type.length > 0 && eval(item_type)) || item_type == null)
				if((item_stats != null && item_stats.length > 0 && eval(item_stats)) || item_stats == null)
					_nb++;
		}
		/*else if(check_inventory_too && _items[i].mode == 0 && _items[i].location == 3)
		{
			var item = _items[i];
			if((item_type != null && item_type.length > 0 && eval(item_type)) || item_type == null)
				if((item_stats != null && item_stats.length > 0 && eval(item_stats)) || item_stats == null)
					if(Config.Inventory[_items[i].y][_items[i].x] > 0) // we check only space that is supposed to be free
						_nb++;
		}*/
	}
	//print("I have "+_nb+" of these.");
	return _nb;
}

function NTIPParseLineInt(input)
{
	var i, property;
	var _start, _end;
	var _section, _keyword;
	var _result;

	_end = input.indexOf("//");

	if(_end != -1)
		input = input.substring(0, _end);

	input = input.replace(/ |;|\t/g, "").toLowerCase();

	if(input.length < 5)
		return null;

	_result = input.split("#");

	if(_result[0] && _result[0].length > 4)
	{
		_section = _result[0].split("[");

		_result[0] = _section[0];

		for(i = 1 ; i < _section.length ; i++)
		{
			_end = _section[i].indexOf("]") + 1;
			property = _section[i].substring(0, _end - 1);

			switch (property) {
			case 'color':
				_result[0] += "item.getColor()";

				break;
			case 'type':
				_result[0] += "item.itemType";

				break;
			case 'name':
				_result[0] += "item.classid";

				break;
			case 'class':
				_result[0] += "item.itemclass";

				break;
			case 'quality':
				_result[0] += "item.quality";

				break;
			case 'flag':
				if(_section[i][_end] == '!')
					_result[0] += "!item.getFlag(";
				else
					_result[0] += "item.getFlag(";

				_end += 2;

				break;
			case 'level':
				_result[0] += "item.ilvl";

				break;
			case 'prefix':
				//_result[0] += "item.prefixnum";
				if(_section[i][_end] == '!')
					_result[0] += "!item.getPrefix(";
				else
					_result[0] += "item.getPrefix(";

				_end += 2;

				break;
			case 'suffix':
				//_result[0] += "item.suffixnum";
				if(_section[i][_end] == '!')
					_result[0] += "!item.getSuffix(";
				else
					_result[0] += "item.getSuffix(";

				_end += 2;

				break;
			default:
				print("Unknown Keyword : " + input);

				break;
			}

			for(_start = _end ; _end < _section[i].length ; _end++)
			{
				if(!NTIPIsSyntaxInt(_section[i][_end]))
					break;
			}

			_result[0] += _section[i].substring(_start, _end);

			for(_start = _end ; _end < _section[i].length ; _end++)
			{
				if(NTIPIsSyntaxInt(_section[i][_end]))
					break;
			}

			_keyword = _section[i].substring(_start, _end);
			
			if (isNaN(_keyword)) {
				switch (property) {
				case 'color':
					if (typeof _NTIPAliasColor[_keyword] === "undefined") {
						_result[0] += "false";
					} else {
						_result[0] += _NTIPAliasColor[_keyword];
					}

					break;
				case 'type':
					if (typeof _NTIPAliasType[_keyword] === "undefined") {
						_result[0] += "false";
					} else {
						_result[0] += _NTIPAliasType[_keyword];
					}

					break;
				case 'name':
					if (typeof _NTIPAliasClassID[_keyword] === "undefined") {
						_result[0] += "false";
					} else {
						_result[0] += _NTIPAliasClassID[_keyword];
					}

					break;
				case 'class':
					if (typeof _NTIPAliasClass[_keyword] === "undefined") {
						_result[0] += "false";
					} else {
						_result[0] += _NTIPAliasClass[_keyword];
					}

					break;
				case 'quality':
					if (typeof _NTIPAliasQuality[_keyword] === "undefined") {
						_result[0] += "false";
					} else {
						_result[0] += _NTIPAliasQuality[_keyword];
					}

					break;
				case 'flag':
					if (typeof _NTIPAliasFlag[_keyword] === "undefined") {
						_result[0] += "false)";
					} else {
						_result[0] += _NTIPAliasFlag[_keyword] + ")";
					}

					break;
				}
			} else {
				if (property == 'flag' || property == 'prefix' || property == 'suffix') {
					_result[0] += _keyword + ")";
				} else {
					_result[0] += _keyword;
				}
			}

			_result[0] += _section[i].substring(_end);
		}
	}
	else
		_result[0] = "";

	if(_result[1] && _result[1].length > 4)
	{
		_section = _result[1].split("[");
		_result[1] = _section[0];

		for(i = 1 ; i < _section.length ; i++)
		{
			_end = _section[i].indexOf("]");
			_keyword = _section[i].substring(0, _end);

			if (isNaN(_keyword)) {
				if (typeof _NTIPAliasStat[_keyword] === "undefined") {
					_result[1] += "false";
				} else {
					_result[1] += "item.getStat(" + _NTIPAliasStat[_keyword] + ")";
				}
			} else {
				_result[1] += "item.getStat(" + _keyword + ")";
			}

			_result[1] += _section[i].substring(_end+1);
		}
	}
	else
		_result[1] = "";

	if(_result[2] && _result[2].replace(/^\s+|\s+$/, "").length > 0)
	{
		_section = _result[2].split("[");
		_result[2] = new Array();

		for(i = 1 ; i < _section.length ; i++)
		{
			_end = _section[i].indexOf("]");

			_keyword = _section[i].substring(0, _end);

			if(_keyword.toLowerCase().replace(/^\s+|\s+$/, "") == "maxquantity")
			{
				_end = _section[i].split("==")[1].replace(/^\s+|\s+$/, "").indexOf("//");
				if(_end == -1)
					_end = _section[i].split("==")[1].replace(/^\s+|\s+$/, "").length;
				var _quantity = parseInt(_section[i].split("==")[1].replace(/^\s+|\s+$/, "").substring(0, _end));
				_result[2]["MaxQuantity"] = _quantity;
			}
			else
			{
				print("Error in your NIP file : unknown 3rd part keyword.");
			}
		}
	}

	return _result;
}

function NTIPIsSyntaxInt(ch)
{
	return (ch == '!' || ch == '%' || ch == '&' || (ch >= '(' && ch <= '+') || ch == '-' || ch == '/' || (ch >= ':' && ch <= '?') || ch == '|');
}

// prototypes

Unit.prototype.__defineGetter__('itemclass',
	function() {
		if (getBaseStat(0, this.classid, 'code') === undefined) {
			return 0;
		}

		if (getBaseStat(0, this.classid, 'code') === getBaseStat(0, this.classid, 'ultracode')) {
			return 2;
		} else if (getBaseStat(0, this.classid, 'code') === getBaseStat(0, this.classid, 'ubercode')) {
			return 1;
		} else {
			return 0;
		}
	}
);

/*
	0 = Black
	1 = White
	2 = Orange
	
	3 = Light Yellow
	4 = Light Red
	5 = Light Gold
	6 = Light Blue
	7 = Light Purple
	
	8 = Crystal Blue
	9 = Crystal Red
	10 = Crystal Green
	
	11 = Dark Yellow
	12 = Dark Red
	13 = Dark Gold
	14 = Dark Green
	15 = Dark Blue
*/

Unit.prototype.getColor = function () {
	var i,
		colors = {
			"Saintly": 16,
			"Holy": 16,
			"Godly": 16,
			"Visionary": 20,
			"Mnemonic": 6,
			"Psychic": 14,
			"Veteran's": 14,
			"of the Mammoth": 9,
			"of Frost Shield": 4,
			"of Nova Shield": 6,
			"Faithful": 20,
			"Dragon's": 6,
			"of Spikes": 19,
			"of Razors": 19,
			"of Swords": 19,
			"of Stability": 14,
			"of the Colosuss": 9,
			"of the Squid": 9,
			"of the Whale": 9,
			"of Defiance": 8,
			"of the Titan": 16,
			"Vulpine": 6,
			"Shimmering": 17,
			"Rainbow": 17,
			"Scintillating": 17,
			"Prismatic": 17,
			"Warden's": 14,
			"Hawk Branded": 14,
			"Commander's": 14,
			"Priest's": 12,
			"Caretaker's": 14,
			"Terrene": 14,
			"Feral": 14,
			"Hierophant's": 12,
			"Resonant": 14,
			"Raging	": 14,
			"Veteran's": 14,
			"Berserker's": 12,
			"Blighting": 14,
			"Noxious": 14,
			"Mojo": 14,
			"Necromancer's": 12,
			"Sensei's": 14,
			"Bowyer's": 14,
			"Gymnastic": 14,
			"Spearmaiden's": 14,
			"Athlete's": 14,
			"Archer's": 14,
			"Kenshi's": 14,
			"Lancer's": 14,
			//"of Alacrity": 14, // on gloves, conflicts with weapons
			"of Wealth": 14,
			"of Fortune": 14,
			"of Luck": 14,
			"Charged": 14,
			"Blazing": 14,
			"Freezing": 14,
			"Trickster's": 14,
			"Witch-hunter's": 12,
			"Arch-Angel's": 12,
			"Valkyrie's": 12,
			"of Perfection": 16,
			"of Regrowth": 9,
			"of Atlas": 16,
			"Massive": 16,
			"Savage": 16,
			"Merciless": 16,
			"Ferocious": 3,
			"Grinding": 20,
			"Cruel": 3,
			"Gold": 14,
			"Platinum": 14,
			"Meteoric": 14,
			"Strange": 14,
			"Weird": 14,
			"Knight's": 16,
			"Lord's": 16,
			"Fool's": 20,
			"King's": 16,
			"Master's": 16,
			"Elysian": 16,
			"Snowy": 4,
			"Shivering": 4,
			"Boreal": 4,
			"Hibernal": 4,
			"Fiery": 8,
			"Smoldering": 8,
			"Smoking": 8,
			"Flaming": 8,
			"Condensing": 8,
			"Static": 13,
			"Glowing": 13,
			"Buzzing": 13,
			"Arcing": 13,
			"Shocking": 13,
			"Septic": 11,
			"Foul": 11,
			"Corrosive": 11,
			"Toxic": 11,
			"Pestilent": 11,
			"of Quickness": 14,
			"of the Glacier": 5,
			"of Winter": 5,
			"of Burning": 8,
			"of Incineration": 8,
			"of Thunder": 14,
			"of Storms": 14,
			"of Carnage": 3,
			"of Slaughter": 3,
			"of Butchery": 3,
			"of Evisceration": 3,
			"of Performance": 3,
			"of Transcendence": 3,
			"of Pestilence": 11,
			"of Anthrax": 11,
			"of the Locust": 9,
			"of the Lamprey": 9,
			"of the Wraith": 9,
			"of the Vampire": 9,
			//"of the Giant": 16,
			"of Icebolt": 4,
			"of Nova": 6,
			"Screaming": 19,
			"Howling": 19,
			"Wailing": 19,
			"Sapphire": 4,
			"Ruby": 7,
			"Amber": 13,
			"Emerald": 12,
			"of Wizardry": 16
		};

	for (i = 0; i < this.suffixes.length; i += 1) {
		if (colors.hasOwnProperty(this.suffixes[i])) {
			return colors[this.suffixes[i]];
		}
	}

	for (i = 0; i < this.prefixes.length; i += 1) {
		if (colors.hasOwnProperty(this.prefixes[i])) {
			return colors[this.prefixes[i]];
		}
	}

	return -1;
}